## Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Захаров И.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Поиски в пространстве состояний используются в разных задачах , и необходимо грамотно выбирать какой метод поиска оучше подойдет к данной задаче . Каждый поиск : в глубину , в ширину и с итерационным погружением имеет свои плюсы и минусы . Мы рассмотрим их в анализе программы и выводе . 

Плюс пролога при решении подобного рода задач заключается в том , что граф состояний , по которому происходит поиск генерируется программой , что позволяет поиску работать с графами неограниченного размера . В нашем случае вершины графа - состояния , а дуги - возможные переходы .


## Задание
Вдоль доски расположено 7 лунок, в которых лежат 3 черных и 3 белых шара.Передвинуть черные шары на место белых, а белые на место черных.Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром. Пустая лунка изначально находится посередине .

## Принцип решения

Для решение задачи я использовал метод поиска в глубину , ширину и с итеративным погружением.

Для начала необходимо было написать предикаты prolong/2 - продление пути и move/2 - поиск состояние , в которое можно перейти из данного состояния.

Они используеются во всех трех методах поисках 

```
move([B1,B2,B3,B4,B5,B6,B7],List):-
	(B1=null,List=[B2,null,B3,B4,B5,B6,B7]);
	(B1=null,List=[B3,B2,null,B4,B5,B6,B7]);

	(B2=null,List=[B1,B3,null,B4,B5,B6,B7]);
	(B2=null,List=[B1,B4,B3,null,B5,B6,B7]);
	(B2=null,List=[null,B1,B3,B4,B5,B6,B7]);
	
	(B3=null,List=[B1,B2,B4,null,B5,B6,B7]);
	(B3=null,List=[B1,null,B2,B4,B5,B6,B7]);
	(B3=null,List=[B1,B2,B5,B4,null,B6,B7]);
	(B3=null,List=[null,B2,B1,B4,B5,B6,B7]);
	
	(B4=null,List=[B1,B2,B3,B5,null,B6,B7]);
	(B4=null,List=[B1,B2,null,B3,B5,B6,B7]);
	(B4=null,List=[B1,null,B3,B2,B5,B6,B7]);
	(B4=null,List=[B1,B2,B3,B6,B5,null,B7]);

	(B5=null,List=[B1,B2,null,B4,B3,B6,B7]);
	(B5=null,List=[B1,B2,B3,null,B4,B6,B7]);
	(B5=null,List=[B1,B2,B3,B4,B6,null,B7]);
	(B5=null,List=[B1,B2,B3,B4,B6,B7,null]);
	
	(B6=null,List=[B1,B2,B3,B4,null,B5,B7]);
	(B6=null,List=[B1,B2,B3,null,B5,B4,B7]);
	(B6=null,List=[B1,B2,B3,B4,B5,B7,null]);
	
	(B7=null,List=[B1,B2,B3,B4,null,B6,B5]);
	(B7=null,List=[B1,B2,B3,B4,B5,null,B6]).
	
prolong([L|List],[Y,L|List]):-
	move(L,Y),
	\+member(Y,List).
```
Далее я написал алгоритм поиска в глубину:
```
search_dpth(Beg,End):-
	dpth([Beg],End,Path),
	reverse(Path,P),
	print_Path(P),!.

dpth([B|List],B,[B|List]).
dpth([L|List],B,Path):-
	prolong([L|List],Res),
	dpth(Res,B,Path).
```
Поиск с итеративным погружением : 
```
natural(1).
natural(X):-
    natural(Y),
    X is Y + 1.

search_id(Beg,End):-
	natural(Depth),
	id([Beg],End,Path,Depth),
	reverse(Path,P),
	print_Path(P),!.

id([B|List],B,[B|List],_).
id([L|List],B,Path,Depth):-
	prolong([L|List],Res),
	length(Res,Len),
	Len<Depth,
	id(Res,B,Path,Depth).
```

На последнем этапе я написал алгоритм поиска в ширину :
```prolog
search_bdth(Beg,End):-
	bdth([[Beg]],End,Path),
	reverse(Path,P),
	print_Path(P),!.

bdth([[B|Queue]|_],B,[B|Queue]).
bdth([Q|Qi],B,Path):-
	setof(Tmp,prolong(Q,Tmp),TmpPath),
	append(Qi,TmpPath,Qo),!,
	bdth(Qo,B,Path),!.
bdth([_|T],Y,L):-
	bdth(T,Y,L).
```
## Результаты
Приведу листинг тестирования программы:
```prolog
| ?- search_dpth([w,w,w,null,b,b,b],[b,b,b,null,w,w,w]).
[w,w,w,null,b,b,b]
[w,w,w,b,null,b,b]
[w,w,null,b,w,b,b]
[w,w,b,null,w,b,b]
[w,w,b,w,null,b,b]
[w,w,b,w,b,null,b]
[w,w,b,null,b,w,b]
[w,w,b,b,null,w,b]
[w,w,null,b,b,w,b]
[w,null,w,b,b,w,b]
[w,b,w,null,b,w,b]
[w,b,w,b,null,w,b]
[w,b,null,b,w,w,b]
[w,b,b,null,w,w,b]
[w,b,b,w,null,w,b]
[w,b,null,w,b,w,b]
[w,null,b,w,b,w,b]
[null,w,b,w,b,w,b]
[b,w,null,w,b,w,b]
[b,w,w,null,b,w,b]
[b,w,w,b,null,w,b]
[b,w,null,b,w,w,b]
[b,w,b,null,w,w,b]
[b,w,b,w,null,w,b]
[b,w,b,w,w,null,b]
[b,w,b,w,w,b,null]
[b,w,b,w,null,b,w]
[b,w,null,w,b,b,w]
[b,w,w,null,b,b,w]
[b,w,w,b,null,b,w]
[b,w,null,b,w,b,w]
[b,w,b,null,w,b,w]
[b,null,b,w,w,b,w]
[b,b,null,w,w,b,w]
[b,b,w,null,w,b,w]
[b,b,w,w,null,b,w]
[b,b,w,w,b,null,w]
[b,b,w,null,b,w,w]
[b,b,w,b,null,w,w]
[b,b,null,b,w,w,w]
[b,b,b,null,w,w,w]

(188 ms) yes
| ?- search_id([w,w,w,null,b,b,b],[b,b,b,null,w,w,w]).
[w,w,w,null,b,b,b]
[w,w,w,b,null,b,b]
[w,w,null,b,w,b,b]
[w,null,w,b,w,b,b]
[w,b,w,null,w,b,b]
[w,b,w,b,w,null,b]
[w,b,w,b,w,b,null]
[w,b,w,b,null,b,w]
[w,b,null,b,w,b,w]
[null,b,w,b,w,b,w]
[b,null,w,b,w,b,w]
[b,b,w,null,w,b,w]
[b,b,w,b,w,null,w]
[b,b,w,b,null,w,w]
[b,b,null,b,w,w,w]
[b,b,b,null,w,w,w]

(984 ms) yes
```
К сожалению , при поиске в ширину переполняется стек , о чем говорит то , что длина очереди достигает 1700 списков . 
Поиск в глубину оказался не самым медленным , но он находит самый длинный путь . В отличие от него поиск с итеративным погрудением показал хорошие результаты , он нашел один из самых коротких решений . Но при этом он дольше ищет , потому что путь решения оказался длиной 16 , что говорит о том , что все погружения с глубиной < 16 оказались неуспешными и это заняло много ресурсов . О поиске в ширину я вообще промолчу . Для данной задачи он абсолютно проигрывает . 

## Выводы

С поисками , изученными при выполнении данной лабораторной я встречался и раньше , поэтому было интересно реализовать их на прологе. Благодаря спискам , код становится довольно небольшим .
Если мы знаем , что между начальным и конечным состоянием небольшое число переходов , то целесообразно использовать поиск в ширину . Если использовать поиск в глубину , то поиск может легко зациклится или бесконечно продлевать путь , даже если решение есть , поэтому и придуман поиск с итеративным погружением.Ну и понятно , что поиск в ширину не выгоден , если цель находится далеко , потому что у нас очередь путей будет расти в геометрической прогрессии.
