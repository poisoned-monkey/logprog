# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Захаров И.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |


## Введение
Так как пролог создавался для обработки текстовой информации , то лабораторная не представляет проблем , однако необходимо было разобраться в работе основных предикатов по работе с списками : append , sort и др . А так же полезно было основить как пролог решает задачи : с помощью рекурсии или хвостовой рекурсии . 

И только после освоения основных способов работы со списками , можно было написать хоть какую-то простую программу .
## Задание 1.1: Предикат обработки списка
Предикат сравнивает два списка (минус в том , что не выдается какой список больше , если они не равны ).

Реализация без использования стандартных предикатов :
Происходит сравнение списка по-элементно
```prolog
lstcmp([],[]):-!.
lstcmp([L|List1],[L|List2]):-
	lstcmp(List1,List2).
```

Реализация с использованием стандартных предикатов :
Просто проверяется , что списки равны , иначе они не равны 
```prolog
lstcmp2(List1,List2):-
	append([],List1,List2).
```

## Задание 1.2: Предикат обработки числового списка

Предикат удаляет первые N элементов списка . 

Реализация без использования стандартных предикатов :
```prolog
deleteN(List,List,0):-!. % число N = 0 , то мы уже удалили первые символы , поэтому полчаем ответ 
deleteN([_|List],Res,N):-
	N1 is N - 1,
	deleteN(List,Res,N1).
```
Эта программа рекурсивная . предикат проходит по списку , отделяя от головы элемент каждый раз , при этом уменьшая счетчик позиции .Когда счетчик - 0 , то мы останавливаемcя . 

Реализация с использованием стандартных предикатов :
```prolog
deleteN2(List,ResList,N):-
	append(Lis,ResList,List), % ищем Lis - длина которого равна N 
	length(Lis,N),!.
```
Простая программа заключается в поиске такого списка , что его длина равна количеству удаляемых символов , соответственно второй список полученный с помощью append - ответ . 

## Задание 2: Реляционное представление данных
Плюсы реляционного представления данных :

Удобное хранение информации ; просто обрабатывать такие данные с помощью предикатов пролога , так как они представляют собой списки . 

Минусы:
Предствление невсегда удобное для работы с такими данными . 

В моем представлении факты записывались так: grade(Group,Subject,Student,Mark).
C помощью встроенного предиката findall/3 можно было легко найти , например список студентов данной группы . Недостатков в таком представлении не нашел (только иногда надо было удалять повторяющиеся элементы из списка).

Вариант 3
1. Для каждого студента, найти средний балл, и сдал ли он экзамены или нет
2. Для каждого предмета, найти количество не сдавших студентов
3. Для каждой группы, найти студента (студентов) с максимальным средним баллом

Вариант реляционного представления : two.pl

Задание 1:
`students_marks(Student,X).` - выводит средний бал студента и сдал ли он все предметы или нет
```prolog
| ?- students_marks('Petrov',X).
X = ['Petrov',3.8333333333333335,'dont pass exams']
(16 ms) yes
| ?- students_marks('Azurin',X).
X = ['Azurin',3.8333333333333335,'pass exams']
yes
| ?- students_marks('Ivanovskij',X).
X = ['Ivanovskij',3.5,'dont pass exams']
yes
```
Листинг:
```prolog
%вычисляет среднюю оценку и степень сдачи экзаменов
mark(Student,[Student,Mark,M]):-
	get_marks(Student,Mark,Pass),
	Pass = 2,
	M = 'dont pass exams',
	!;
	get_marks(Student,Mark,Pass),
	M = 'pass exams',!.

check([2|_],2):-!.
check([],1):-!.
check([M|Marks],Pass):-
	check(Marks,Pass).
	
get_marks(Y,Mark,Pass):-%средняя оценка студента
	findall(Mrk,grade(_,Y,_,Mrk),Marks),
	get_sum_mark(Marks,M),
	check(Marks,Pass),
	length(Marks,Len),
	Mark is M / Len.

get_sum_mark([],0).%сумма оценок студента
get_sum_mark([Y|Marks],M):-
	get_sum_mark(Marks,N),
	M is N + Y.

students_marks(Student,X):-
	mark(Student,X).
```
Задание 2:
`dont_pass_exams(Subject,X).` - выводит количество студентов , несдавших этот предмет
```prolog
| ?- dont_pass_exams('Matematicheskij analiz',X).
X = ['Matematicheskij analiz',3]
yes
| ?- dont_pass_exams('Informatika',X).
X = ['Informatika',2]
yes
```
Листинг:
```prolog
count([],0).%считает число двоек для данного предмета
count([_|S],Number):-
	count(S,N),
	Number is N + 1.
%создает список из n названий предмета
get_dont_passed(N,[N,Number]):-
	findall(N,grade(_,_,N,2),Subj),
	count(Subj,Number).
	
dont_pass_exams(Subject,X):-
	get_dont_passed(Subject,X).
```
Задание 3:
`max_mark(Group,X).` -  выводит максимальный средний бал в группе.
```prolog
| ?- max_mark(104,X).
X = [104,4.166666666666667]
(16 ms) yes
| ?- max_mark(101,X).
X = [101,4.833333333333333]
yes
```
Листинг:
```prolog
%создает список без повторений
no_repeats([], []):-!.
no_repeats([X|Xs], Ys):-
	member(X, Xs),!,
	no_repeats(Xs, Ys).
no_repeats([X|Xs], [X|Ys]):-
	no_repeats(Xs, Ys).
	%сумма оценок студента
sum_mark([],0).
sum_mark([Y|Marks],M):-
	sum_mark(Marks,N),
	M is N + Y.
	%считает масимальную среднюю оценку среди списка оценок
calc_max_group_mark([],Result,Max):-
	Result = Max,!.
calc_max_group_mark([M|Marks],Result,Max):-
	M > Max,
	calc_max_group_mark(Marks,Result,M);
	calc_max_group_mark(Marks,Result,Max).
	%получает среднюю оценку для всех студентов группы
get_average_marks([],[]):-!.
get_average_marks([S|Students],[Max|M]):-
	findall(X,grade(_,S,_,X),Marks),
	sum_mark(Marks,N),
	length(Marks,Len),
	Max is N / Len,
	get_average_marks(Students,M).

make_list(G,[G,Max]):-%создает список студентов группы
	findall(S,grade(G,S,_,_),Stud),
	no_repeats(Stud,Students),
	get_average_marks(Students,Marks),
	calc_max_group_mark(Marks,Max,0).

max_mark(Group,X):-
	make_list(Group,X),!.
```

## Выводы

Я считаю , что пролог - очень полезный язык для работы с символьными структурыми данных . Для написания программ из второй части на языках императивного типа понадобилось бы намного больше ненужной работы . Пролог же сам ищет данные , т.е. не нужно организовывать поиск по базе данных . Аналогично пролог полезен для решения задач из первой части. 

При выполнении данной работы нужно было понять , как думает пролог , когда выполняет задачи . Для этого я нашел специально узнал про трассировку с помощью trace. Это очень помогает , так как самому прокрутить программу в поисках ошибки - трудно .